package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

var prefix = flag.String("prefix", "", "option prefix")

func main() {
	flag.Parse()

	err := runMain()
	if err != nil {
		panic(err)
	}
}

type specValue struct {
	typ     *ast.TypeSpec
	comment *ast.Comment
}

const directive = "//troptgen:"
const rootPackage = "github.com/rrgmc/trcache"

func runMain() error {

	cfg := packages.Config{
		Mode: packages.NeedName | packages.NeedImports | packages.NeedDeps | packages.NeedTypes |
			packages.NeedSyntax | packages.NeedTypesInfo,
		ParseFile: func(fset *token.FileSet, filename string, src []byte) (*ast.File, error) {
			return parser.ParseFile(fset, filename, src, parser.ParseComments)
		},
	}

	pkgs, err := packages.Load(&cfg, "./")
	if err != nil {
		return fmt.Errorf("cannot load %q: %w", "./", err)
	}
	if len(pkgs) != 1 {
		return fmt.Errorf("packages.Load returned %d packages, not 1", len(pkgs))
	}

	pkg := pkgs[0]

	specs := make(map[string][]specValue)

	for _, syntax := range pkg.Syntax {
		s := getTaggedComments(syntax)
		for _, sp := range s {
			filename := pkg.Fset.Position(syntax.Package).Filename
			fn, ok := specs[filename]
			if !ok {
				fn = []specValue{}
				specs[filename] = fn
			}
			specs[filename] = append(specs[filename], sp)
		}
	}

	for filename, fnspecs := range specs {
		dir, file := filepath.Split(filename)
		newfile := filepath.Join(dir, fmt.Sprintf("%s_gen%s", strings.TrimSuffix(file, filepath.Ext(filename)), filepath.Ext(filename)))

		f := jen.NewFilePathName(pkg.PkgPath, pkg.Name)
		// f.NoFormat = true
		f.HeaderComment("Code generated by troptgen. DO NOT EDIT.")

		optionsimpltype := map[string]*jen.Statement{}
		optionsimpl := map[string]*jen.Statement{}
		optionsimplfuncs := map[string]*jen.Statement{}
		optionsfuncs := map[string]*jen.Statement{}

		cmds := []string{"root", "get", "set", "delete", "refresh"}

		for _, stype := range fnspecs {
			obj := pkg.Types.Scope().Lookup(stype.typ.Name.Name)
			if obj == nil {
				continue
			}

			stinterface, ok := stype.typ.Type.(*ast.InterfaceType)
			if !ok {
				continue
			}

			// root, get, set, delete, refresh
			directiveList := strings.Split(strings.TrimSpace(strings.TrimPrefix(stype.comment.Text, directive)), " ")
			var directiveCmd string
			directiveParams := map[string]string{}
			for didx, dcms := range directiveList {
				if didx == 0 {
					directiveCmd = dcms
				} else {
					if dn, dv, ok := strings.Cut(dcms, "="); ok {
						directiveParams[dn] = dv
					}
				}
			}

			// isDefaultDirective := true
			UCDefaultDirectiveCMD := makeFirstUpperCase(directiveCmd)
			UCDefaultDirectiveCMDOptional := makeFirstUpperCase(directiveCmd)
			if directiveCmd == "root" {
				UCDefaultDirectiveCMDOptional = ""
			}

			var implStructPrefix string
			if dname, ok := directiveParams["name"]; ok {
				// isDefaultDirective = false
				directiveCmd = fmt.Sprintf("%s%s", directiveCmd, makeFirstUpperCase(dname))
				cmds = append(cmds, directiveCmd)
				implStructPrefix = dname
			}

			// UCDirectiveCMD := makeFirstUpperCase(directiveCmd)
			// UCDirectiveCMDOptional := UCDirectiveCMD
			// if strings.HasPrefix(directiveCmd, "root") {
			// 	UCDirectiveCMDOptional = strings.TrimPrefix(directiveCmd, "root")
			// }

			// only named interface types are supported
			namedType, ok := obj.Type().(*types.Named)
			if !ok {
				return fmt.Errorf("only interface types are supported: %s", obj.String())
			}

			if *prefix != "" && !strings.HasPrefix(namedType.Obj().Name(), *prefix) {
				continue
			}

			interfaceType, ok := namedType.Underlying().(*types.Interface)
			if !ok {
				return fmt.Errorf("only interface types are supported: %s", obj.String())
			}

			// don't create implementations on the main package
			isImpl := false
			if pkg.PkgPath != rootPackage {
				isImpl = true
			}

			// initialize implementation statements
			if isImpl {
				_, optiok := optionsimpl[directiveCmd]
				if !optiok {
					optionsimpl[directiveCmd] = &jen.Statement{}
				}

				_, optifok := optionsimplfuncs[directiveCmd]
				if !optifok {
					optionsimplfuncs[directiveCmd] = &jen.Statement{}
				}

				// create the implementation struct definition
				if _, itok := optionsimpltype[directiveCmd]; !itok {
					optionsimpltype[directiveCmd] = jen.
						Type().
						Id(implStructName(namedType.Obj().Name(), implStructPrefix)).
						Add(FromTypeParams(namedType.TypeParams()))
				}

				// add var to ensure struct implements the interface
				optionsimplfuncs[directiveCmd].Add(
					jen.Var().
						Id("_").Id(namedType.Obj().Name()).Add(CallFromTypeParamsFixed(namedType.TypeParams(), "string")).
						Op("=").
						Id(fmt.Sprintf("&%s", implStructName(namedType.Obj().Name(), implStructPrefix))).Add(CallFromTypeParamsFixed(namedType.TypeParams(), "string")).
						Values(jen.Dict{}),
				)
			}

			_, optfok := optionsfuncs[directiveCmd]
			if !optfok {
				optionsfuncs[directiveCmd] = &jen.Statement{}
				// if isDefaultDirective && pkg.PkgPath != rootPackage {
				// 	optionsfuncs[directiveCmd].Add(
				// 		jen.Type().
				// 			Id(fmt.Sprintf("%sOption", UCDefaultDirectiveCMD)).
				// 			Op("=").
				// 			Qual(rootPackage, fmt.Sprintf("%sOption", UCDefaultDirectiveCMD)),
				// 	)
				// }
			}

			explicitMethods := map[*types.Func]bool{}
			for i := 0; i < interfaceType.NumExplicitMethods(); i++ {
				explicitMethods[interfaceType.ExplicitMethod(i)] = true
			}

			for i := 0; i < interfaceType.NumMethods(); i++ {
				method := interfaceType.Method(i)

				// if !method.Exported() {
				if !strings.HasPrefix(method.Name(), "Opt") && !strings.HasPrefix(method.Name(), "opt") {
					continue
				}

				methodPrefix := method.Name()[0:3]
				withPrefix := "With"
				if methodPrefix == "opt" {
					withPrefix = "with"
				}

				baseMethodName := strings.TrimPrefix(method.Name(), methodPrefix)
				optionMethodName := fmt.Sprintf("%s/%s.%s", namedType.Obj().Pkg().Path(), namedType.Obj().Name(), baseMethodName)
				methodName := fmt.Sprintf("%s%s%s%s", withPrefix, makeFirstUpperCase(*prefix), UCDefaultDirectiveCMDOptional, baseMethodName)
				defaultMethodName := fmt.Sprintf("%s%s%s", withPrefix, UCDefaultDirectiveCMDOptional, baseMethodName)
				fsig := method.Type().(*types.Signature)

				methodDoc := getMethodComments(stinterface, method.Name())
				methodDoc = strings.Replace(methodDoc, method.Name(), methodName, 1)

				if isImpl && fsig.Params().Len() > 0 {
					// add implementation field to struct
					implFieldName := makeFirstLowerCase(baseMethodName)

					for p := 0; p < fsig.Params().Len(); p++ {
						iname := implFieldName
						if fsig.Params().Len() > 1 {
							iname = fmt.Sprintf("%s%s", implFieldName, makeFirstUpperCase(fsig.Params().At(p).Name()))
						}
						optionsimpl[directiveCmd].Add(
							jen.Id(checkKeyword(iname)).Add(QualFromType(fsig.Params().At(p).Type())),
						)
					}

					// add implementation method to struct
					optionsimplfuncs[directiveCmd].Add(
						jen.Func().
							Params(jen.Id("o").Id(fmt.Sprintf("*%s", implStructName(namedType.Obj().Name(), implStructPrefix))).Add(CallFromTypeParams(namedType.TypeParams()))).
							Id(method.Name()).
							Add(FromParams(fsig.Params(), fsig.Variadic())).
							BlockFunc(func(g *jen.Group) {
								for p := 0; p < fsig.Params().Len(); p++ {
									iname := implFieldName
									if fsig.Params().Len() > 1 {
										iname = fmt.Sprintf("%s%s", implFieldName, makeFirstUpperCase(fsig.Params().At(p).Name()))
									}
									g.Id("o").Dot(checkKeyword(iname)).Op("=").Id(ParamName(fsig.Params().At(p), 0))
								}
							}),
					)
				}

				_, isExplicitMethod := explicitMethods[method]

				// "With" are added only for explicit methods
				if !isExplicitMethod {
					continue
				}

				// generate a "With" function for each interface method
				if methodDoc != "" {
					optionsfuncs[directiveCmd].Add(
						jen.Comment(methodDoc),
					)
				}

				optionsfuncs[directiveCmd].Add(
					jen.Func().Id(methodName).
						Add(FromTypeParams(namedType.TypeParams())).
						Add(FromParams(fsig.Params(), fsig.Variadic())).
						Qual(rootPackage, fmt.Sprintf("%sOption", UCDefaultDirectiveCMD)).
						// Id(fmt.Sprintf("%sOption", UCDefaultDirectiveCMD)).
						BlockFunc(func(g *jen.Group) {
							if isExplicitMethod {
								g.Const().Id("optionName").Op("=").Lit(optionMethodName)
								hash, err := OptionHashGen(optionMethodName)
								if err != nil {
									panic(fmt.Errorf("cannot calculate option hash: %v", err))
								}
								g.Const().Id("optionHash").Op("=").Lit(hash)

								g.Return(
									jen.Qual(rootPackage, fmt.Sprintf("%sOptionFunc", UCDefaultDirectiveCMD)).Call(
										jen.Func().
											Params(jen.Id("o").Id("any")).
											Bool().
											BlockFunc(func(g *jen.Group) {
												g.Switch(jen.Id("opt").Op(":=").Id("o.(type)").Block(
													jen.Case(QualFromType(namedType)).Block(
														jen.Id("opt").Dot(method.Name()).Add(CallFromParams(fsig.Params(), fsig.Variadic())),
													),
													jen.Return(jen.True()),
												))

												g.Return(jen.False())
											}),
										jen.Id("optionName"),
										jen.Id("optionHash"),
									),
								)
							} else {
								// alias (currently disabled)
								parentNamedType, ok := fsig.Recv().Type().(*types.Named)
								if ok {
									g.Return(
										jen.Qual(rootPackage, defaultMethodName).
											Add(CallFromTypeParams(parentNamedType.TypeParams())).
											Add(CallFromParams(fsig.Params(), fsig.Variadic())),
									)
								}
							}
						}),
				)
			}
		}

		// generate an options func for each interface method
		for _, d := range cmds {
			ob, ok := optionsfuncs[d]
			if !ok {
				continue
			}

			for _, obi := range *ob {
				f.Add(obi)
			}
		}

		// generate an impl struct for each option interface and an impl method for each interface method
		for _, d := range cmds {
			ob, ok := optionsimpl[d]
			if !ok {
				continue
			}

			if obt, ok := optionsimpltype[d]; ok {
				f.Add(obt.StructFunc(func(g *jen.Group) {
					for _, obi := range *ob {
						g.Add(obi)
					}
				}))
			}

			of, ok := optionsimplfuncs[d]
			if !ok {
				continue
			}

			for _, ofi := range *of {
				f.Add(ofi)
			}
		}

		err = f.Save(newfile)
		if err != nil {
			return err
		}
	}

	return nil
}

func implStructName(interfaceName string, prefix string) string {
	if prefix != "" {
		interfaceName = prefix
	}
	ret := makeFirstLowerCase(interfaceName)
	if ret == "options" {
		ret = "rootOptions"
	}
	return fmt.Sprintf("%sImpl", ret)
}

// getTaggedComments walks the AST and returns types which have directive comment
// returns a map of TypeSpec to directive
func getTaggedComments(pkg ast.Node) []specValue {
	var specs []specValue

	ast.Inspect(pkg, func(n ast.Node) bool {
		g, ok := n.(*ast.GenDecl)

		// is it a type?
		// http://golang.org/pkg/go/ast/#GenDecl
		if !ok || g.Tok != token.TYPE {
			// never mind, move on
			return true
		}

		if g.Lparen == 0 {
			// not parenthesized, copy GenDecl.Doc into TypeSpec.Doc
			g.Specs[0].(*ast.TypeSpec).Doc = g.Doc
		}

		for _, s := range g.Specs {
			t := s.(*ast.TypeSpec)

			if c := findAnnotation(t.Doc); c != nil {
				specs = append(specs, specValue{
					typ:     t,
					comment: c,
				})
			}
		}

		// no need to keep walking, we don't care about TypeSpec's children
		return false
	})

	return specs
}

// findDirective return the first line of a doc which contains a directive
// the directive and '//' are removed
func findAnnotation(doc *ast.CommentGroup) *ast.Comment {
	if doc == nil {
		return nil
	}

	// check lines of doc for directive
	for _, c := range doc.List {
		if strings.HasPrefix(c.Text, directive) {
			return c
		}
	}

	return nil
}

func getMethodComments(intf *ast.InterfaceType, method string) string {
	for _, field := range intf.Methods.List {
		found := false
		for _, name := range field.Names {
			if name.Name == method {
				found = true
				break
			}
		}
		if !found {
			continue
		}

		var ret []string
		if field.Doc != nil {
			for _, doc := range field.Doc.List {
				ret = append(ret, doc.Text)
			}
		}
		return strings.Join(ret, "\n")
	}
	return ""
}

func checkIsImpl(interfaceType *types.Interface, UCDirectiveCMD string, firstLevel bool) (isImpl bool, isImplFirstLevel bool) {
	for i := 0; i < interfaceType.NumEmbeddeds(); i++ {
		et := interfaceType.EmbeddedType(i)
		if etNamedType, ok := et.(*types.Named); ok {
			if etNamedType.Obj().Pkg().Path() == rootPackage &&
				etNamedType.Obj().Name() == fmt.Sprintf("Is%sOptions", UCDirectiveCMD) {
				return true, firstLevel
			}
			// recursive check
			if innerInterfaceType, ok := etNamedType.Underlying().(*types.Interface); ok {
				if ok, _ := checkIsImpl(innerInterfaceType, UCDirectiveCMD, false); ok {
					return true, false
				}
			}
		}
	}
	return false, false
}

func makeFirstUpperCase(s string) string {
	if len(s) == 0 {
		return s
	}

	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

func makeFirstLowerCase(s string) string {
	if len(s) == 0 {
		return s
	}

	r := []rune(s)
	r[0] = unicode.ToLower(r[0])
	return string(r)
}

func checkKeyword(s string) string {
	for token.Lookup(s).IsKeyword() {
		s = s + "x"
	}
	return s
}
